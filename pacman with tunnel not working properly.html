<!DOCTYPE html>
<html>
<head>
    <title></title>
    <link rel="stylesheet" type="text/css" href="pacman.css">
</head>
<body>
<div class="ijkl"></div>
</body>

<script type="text/javascript">

    str = "";
    b = document.getElementsByTagName("body")[0];
    ROW_MAX = 31;
    COL_MAX = 28;
    blinkySpeed = 500;
    pacmanSpeed = 200;
    pacmanDirection = {x: 1, y: 0};
    tunnelStart = {x:14 ,y: 0};
    tunnelEnd = {x:14 ,y: 27};

    class Queue {
        constructor() {
            this.items = [];
        }
        isEmpty() {
            return this.items.length === 0;
        }
        enqueue(elements) {
            this.items.push(elements);
        }
        dequeue() {
            if(this.isEmpty())
                return "Underflow";
            return this.items.shift();
        }
        front() {
            if(this.isEmpty())
                return "No elements in Queue";
            return this.items[0];
        }
        printQueue() {
            var str = "";
            for(var i = 0; i < this.items.length; i++)
                str += "(" + this.items[0].pt.x.toString() + ", " + this.items[0].pt.y.toString() + "), " + this.items[0].dist + "; ";
            return str;
        }
    }

    function levelGenerator(level) {
        if(level === 1) {
            return ([
                ['B1', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'E7', 'E1', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B7'],
                ['B6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'b2', 'b6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'B2'],
                ['B6', 'pp', 'b1', 'b8', 'b8', 'b7', 'pp', 'b1', 'b8', 'b8', 'b8', 'b7', 'pp', 'b2', 'b6', 'pp', 'b1', 'b8', 'b8', 'b8', 'b7', 'pp', 'b1', 'b8', 'b8', 'b7', 'pp', 'B2'],
                ['B6', 'PP', 'b2', 'ze', 'ze', 'b6', 'pp', 'b2', 'ze', 'ze', 'ze', 'b6', 'pp', 'b2', 'b6', 'pp', 'b2', 'ze', 'ze', 'ze', 'b6', 'pp', 'b2', 'ze', 'ze', 'b6', 'PP', 'B2'],
                ['B6', 'pp', 'b3', 'b4', 'b4', 'b5', 'pp', 'b3', 'b4', 'b4', 'b4', 'b5', 'pp', 'b3', 'b5', 'pp', 'b3', 'b4', 'b4', 'b4', 'b5', 'pp', 'b3', 'b4', 'b4', 'b5', 'pp', 'B2'],
                ['B6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'B2'],
                ['B6', 'pp', 'b1', 'b8', 'b8', 'b7', 'pp', 'b1', 'b7', 'pp', 'b1', 'b8', 'b8', 'b8', 'b8', 'b8', 'b8', 'b7', 'pp', 'b1', 'b7', 'pp', 'b1', 'b8', 'b8', 'b7', 'pp', 'B2'],
                ['B6', 'pp', 'b3', 'b4', 'b4', 'b5', 'pp', 'b2', 'b6', 'pp', 'b3', 'b4', 'b4', 'b7', 'b1', 'b4', 'b4', 'b5', 'pp', 'b2', 'b6', 'pp', 'b3', 'b4', 'b4', 'b5', 'pp', 'B2'],
                ['B6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'b2', 'b6', 'pp', 'pp', 'pp', 'pp', 'b2', 'b6', 'pp', 'pp', 'pp', 'pp', 'b2', 'b6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'B2'],
                ['B3', 'B8', 'B8', 'B8', 'B8', 'b7', 'pp', 'b2', 'b3', 'b8', 'b8', 'b7', 'pp', 'b2', 'b6', 'pp', 'b1', 'b8', 'b8', 'b5', 'b6', 'pp', 'b1', 'B8', 'B8', 'B8', 'B8', 'B5'],
                ['ze', 'ze', 'ze', 'ze', 'ze', 'B6', 'pp', 'b2', 'b1', 'b4', 'b4', 'b5', 'pp', 'b3', 'b5', 'pp', 'b3', 'b4', 'b4', 'b7', 'b6', 'pp', 'B2', 'ze', 'ze', 'ze', 'ze', 'ze'],
                ['ze', 'ze', 'ze', 'ze', 'ze', 'B6', 'pp', 'b2', 'b6', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'b2', 'b6', 'pp', 'B2', 'ze', 'ze', 'ze', 'ze', 'ze'],
                ['ze', 'ze', 'ze', 'ze', 'ze', 'B6', 'pp', 'b2', 'b6', 'ze', 'H1', 'B8', 'L8', 'H8', 'H8', 'R8', 'B8', 'H7', 'ze', 'b2', 'b6', 'pp', 'B2', 'ze', 'ze', 'ze', 'ze', 'ze'],
                ['B4', 'B4', 'B4', 'B4', 'B4', 'b5', 'pp', 'b3', 'b5', 'ze', 'B2', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'B6', 'ze', 'b3', 'b5', 'pp', 'b3', 'B4', 'B4', 'B4', 'B4', 'B4'],
                ['ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'pp', 'ze', 'ze', 'ze', 'B2', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'B6', 'ze', 'ze', 'ze', 'pp', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze'],
                ['B8', 'B8', 'B8', 'B8', 'B8', 'b7', 'pp', 'b1', 'b7', 'ze', 'B2', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'B6', 'ze', 'b1', 'b7', 'pp', 'b1', 'B8', 'B8', 'B8', 'B8', 'B8'],
                ['ze', 'ze', 'ze', 'ze', 'ze', 'B6', 'pp', 'b2', 'b6', 'ze', 'H3', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'H5', 'ze', 'b2', 'b6', 'pp', 'B2', 'ze', 'ze', 'ze', 'ze', 'ze'],
                ['ze', 'ze', 'ze', 'ze', 'ze', 'B6', 'pp', 'b2', 'b6', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'b2', 'b6', 'pp', 'B2', 'ze', 'ze', 'ze', 'ze', 'ze'],
                ['ze', 'ze', 'ze', 'ze', 'ze', 'B6', 'pp', 'b2', 'b6', 'ze', 'b1', 'b8', 'b8', 'b8', 'b8', 'b8', 'b8', 'b7', 'ze', 'b2', 'b6', 'pp', 'B2', 'ze', 'ze', 'ze', 'ze', 'ze'],
                ['B1', 'B4', 'B4', 'B4', 'B4', 'b5', 'pp', 'b3', 'b5', 'ze', 'b3', 'b4', 'b4', 'b7', 'b1', 'b4', 'b4', 'b5', 'ze', 'b3', 'b5', 'pp', 'b3', 'B4', 'B4', 'B4', 'B4', 'B7'],
                ['B6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'b2', 'b6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'B2'],
                ['B6', 'pp', 'b1', 'b8', 'b8', 'b7', 'pp', 'b1', 'b8', 'b8', 'b8', 'b7', 'pp', 'b2', 'b6', 'pp', 'b1', 'b8', 'b8', 'b8', 'b7', 'pp', 'b1', 'b8', 'b8', 'b7', 'pp', 'B2'],
                ['B6', 'pp', 'b3', 'b4', 'b7', 'b6', 'pp', 'b3', 'b4', 'b4', 'b4', 'b5', 'pp', 'b3', 'b5', 'pp', 'b3', 'b4', 'b4', 'b4', 'b5', 'pp', 'b2', 'b1', 'b4', 'b5', 'pp', 'B2'],
                ['B6', 'PP', 'pp', 'pp', 'b2', 'b6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'b2', 'b6', 'pp', 'pp', 'PP', 'B2'],
                ['E3', 'b8', 'b7', 'pp', 'b2', 'b6', 'pp', 'b1', 'b7', 'pp', 'b1', 'b8', 'b8', 'b8', 'b8', 'b8', 'b8', 'b7', 'pp', 'b1', 'b7', 'pp', 'b2', 'b6', 'pp', 'b1', 'b8', 'E5'],
                ['C8', 'b4', 'b5', 'pp', 'b3', 'b5', 'pp', 'b2', 'b6', 'pp', 'b3', 'b4', 'b4', 'b7', 'b1', 'b4', 'b4', 'b5', 'pp', 'b2', 'b6', 'pp', 'b3', 'b5', 'pp', 'b3', 'b4', 'C9'],
                ['B6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'b2', 'b6', 'pp', 'pp', 'pp', 'pp', 'b2', 'b6', 'pp', 'pp', 'pp', 'pp', 'b2', 'b6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'B2'],
                ['B6', 'pp', 'b1', 'b8', 'b8', 'b8', 'b8', 'b5', 'b3', 'b8', 'b8', 'b7', 'pp', 'b2', 'b6', 'pp', 'b1', 'b8', 'b8', 'b5', 'b3', 'b8', 'b8', 'b8', 'b8', 'b7', 'pp', 'B2'],
                ['B6', 'pp', 'b3', 'b4', 'b4', 'b4', 'b4', 'b4', 'b4', 'b4', 'b4', 'b5', 'pp', 'b3', 'b5', 'pp', 'b3', 'b4', 'b4', 'b4', 'b4', 'b4', 'b4', 'b4', 'b4', 'b5', 'pp', 'B2'],
                ['B6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'B2'],
                ['B3', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B5']
            ]);
        }
    }
    function generateVisited() {
        var visited = [], temp = [], i, j;
        for(i = 0; i < ROW_MAX; i++)
        {
            temp = [];
            for(j = 0; j < COL_MAX; j++)
                temp.push(0);
            visited[i] = temp;
        }
        return visited;
    }

    function isValid(row, col)
    {
        // return true if row pacmanInterval and column pacmanInterval is in range
        return ((row >= 0) && (row < ROW_MAX) && (col >= 0) && (col < COL_MAX));
    }

    // These arrays are used to get row and column
    // pacmanIntervals of 4 neighbours of a given cell
    rowNum = [-1, 0, 0, 1];
    colNum = [0, -1, 1, 0];

    function findPath(matrix, blinkyPos, pacmanPos, pathToPacman, blinkyMotionDirection) {
        // check source and destination cell
        // of the matrix have value 1
        if (!(matrix[blinkyPos.x][blinkyPos.y] === 'H8' || matrix[blinkyPos.x][blinkyPos.y] === 'ze' || matrix[pacmanPos.x][pacmanPos.y] === 'ze' || matrix[blinkyPos.x][blinkyPos.y] === 'pp' || matrix[pacmanPos.x][pacmanPos.y] === 'pp' || matrix[blinkyPos.x][blinkyPos.y] === 'PP' || matrix[pacmanPos.x][pacmanPos.y] === 'PP')) {
            return -1;
        }

//        bool visited[ROW][COL];
//        memset(visited, false, sizeof visited);
        var visited = generateVisited();

        // Mark the source cell as visited
        visited[blinkyPos.x][blinkyPos.y] = 1;

        // Create a queue for BFS
        var q = new Queue();

        // distance of source cell is 0
        var s = {pt: blinkyPos, dist: 0};
        q.enqueue(s);  // Enqueue source cell

        var count = 0, str3 = "", temp = [];
        // Do a BFS starting from source cell
        while (q.isEmpty() !== true)
        {
            var curr = q.front();
            var pt = curr.pt;

            temp[count++] = curr;
//            console.log(q.printQueue())
//            console.log(pathToPacman[count-1].printQueue());
            // If we have reached the destination cell,
            // we are done
            if (pt.x === pacmanPos.x && pt.y === pacmanPos.y) {
//                for(var k = 0; k < temp.length; k++)
//                    str3 += "(" + temp[k].pt.x.toString() + ", " + temp[k].pt.y.toString() + "), " + temp[k].dist + "; ";
//
//                str3 += "<br><br><br><br>";
                var earlierPoint = temp[temp.length - 1];
                var correctPathFound = false, l;
                for(l = temp.length - 2; l >= 0; l--) {
                    if((temp[l].pt.x === earlierPoint.pt.x && Math.abs(temp[l].pt.y - earlierPoint.pt.y) === 1) || (temp[l].pt.y === earlierPoint.pt.y && Math.abs(temp[l].pt.x - earlierPoint.pt.x) === 1)) {
                        if(temp[l].pt.x === pacmanPos.x && temp[l].pt.y === pacmanPos.y)
                            correctPathFound = true;
                        pathToPacman.push(temp[l].pt);
                        earlierPoint = temp[l];
//                        str3 += "(" + temp[l].pt.x.toString() + ", " + temp[l].pt.y.toString() + "), " + temp[l].dist + "; ";
                    }
                }//case I: without portal
                if(correctPathFound === false) {
                    pathToPacman.length = 0;                   // making the same state of variable which
                    earlierPoint = temp[temp.length - 1];// was distruebed by unsuccessfull case I loop
                    for(l = temp.length - 2; l >= 0; l--) {
                        if (temp[l].pt.x === tunnelStart.x && temp[l].pt.y === tunnelStart.y) {
                            if(temp[l].pt.x === pacmanPos.x && temp[l].pt.y === pacmanPos.y)
                                correctPathFound = true;
                            pathToPacman.push(temp[l].pt);
                            earlierPoint = temp[l];
                        }
                        else if ((temp[l].pt.x === earlierPoint.pt.x && Math.abs(temp[l].pt.y - earlierPoint.pt.y) === 1) || (temp[l].pt.y === earlierPoint.pt.y && Math.abs(temp[l].pt.x - earlierPoint.pt.x) === 1)) {
                            if(temp[l].pt.x === pacmanPos.x && temp[l].pt.y === pacmanPos.y)
                                correctPathFound = true;
                            pathToPacman.push(temp[l].pt);
                            earlierPoint = temp[l];
//                        str3 += "(" + temp[l].pt.x.toString() + ", " + temp[l].pt.y.toString() + "), " + temp[l].dist + "; ";
                        }
                    }//case II: with tunnel start portal
                }
                else if(correctPathFound === false) {
                    pathToPacman.length = 0;                   // making the same state of variable which
                    earlierPoint = temp[temp.length - 1];// was distruebed by unsuccessfull case I loop
                    for(l = temp.length - 2; l >= 0; l--) {
                        if (temp[l].pt.x === tunnelEnd.x && temp[l].pt.y === tunnelEnd.y) {
                            if(temp[l].pt.x === pacmanPos.x && temp[l].pt.y === pacmanPos.y)
                                correctPathFound = true;
                            pathToPacman.push(temp[l].pt);
                            earlierPoint = temp[l];
                        }
                        else if ((temp[l].pt.x === earlierPoint.pt.x && Math.abs(temp[l].pt.y - earlierPoint.pt.y) === 1) || (temp[l].pt.y === earlierPoint.pt.y && Math.abs(temp[l].pt.x - earlierPoint.pt.x) === 1)) {
                            if(temp[l].pt.x === pacmanPos.x && temp[l].pt.y === pacmanPos.y)
                                correctPathFound = true;
                            pathToPacman.push(temp[l].pt);
                            earlierPoint = temp[l];
//                        str3 += "(" + temp[l].pt.x.toString() + ", " + temp[l].pt.y.toString() + "), " + temp[l].dist + "; ";
                        }
                    }//case III: with tunnel end portal
                }
//                b.innerHTML += str3;
                pathToPacman = pathToPacman.reverse();
                pathToPacman.push(pacmanPos);

//                if((pacmanPos.x === tunnelStart.x && pacmanPos.y === tunnelStart.y ) || (pacmanPos.x === tunnelEnd.x && pacmanPos.y === tunnelEnd.y )) {
//                    console.log(pathToPacman);
//                    console.log(temp);
//                }

                return curr.dist;
            }

            // Otherwise dequeue the front cell in the queue
            // and enqueue its adjacent cells
            q.dequeue();

            for (var i = 0; i < 4; i++)
            {
                if(count === 1 && blinkyMotionDirection.x === -1 * rowNum[i] && blinkyMotionDirection.y === -1 * colNum[i])
                    continue;
                var row = pt.x + rowNum[i];
                var col = pt.y + colNum[i];
                if(pt.x === tunnelEnd.x && pt.y === tunnelEnd.y && i === 2 && visited[tunnelStart.x][tunnelStart.y] === 0) {
                    row = tunnelStart.x;
                    col = tunnelStart.y;
                    visited[row][col] = 1;
                    var adjCell = {pt: {x: row, y: col}, dist: curr.dist + 1};
                    q.enqueue(adjCell);
                }
                if(pt.x === 14 && pt.y === 0 && i === 1 && visited[tunnelEnd.x][tunnelEnd.y] === 0) {
                    row = tunnelEnd.x;
                    col = tunnelEnd.y;
                    visited[row][col] = 1;
                    var adjCell = {pt: {x: row, y: col}, dist: curr.dist + 1};
                    q.enqueue(adjCell);
                }
                // if adjacent cell is valid, has path and
                // not visited yet, enqueue it.
                if (isValid(row, col) === true && (matrix[row][col] === 'pp' || matrix[row][col] === 'PP' || matrix[row][col] === 'H8' || matrix[row][col] === 'ze') && visited[row][col] === 0)
                {
                    // mark cell as visited and enqueue it
                    visited[row][col] = 1;
                    var adjCell = {pt: {x: row, y: col}, dist: curr.dist + 1};
                    q.enqueue(adjCell);
                }
//                else if ((row === tunnelStart.x && col === tunnelStart.y - 1 && visited[tunnelEnd.x][tunnelEnd.y] === 0) || (row === tunnelEnd.x && col === tunnelEnd.y + 1 && visited[tunnelStart.x][tunnelStart.y] === 0)) {
//                    console.log(row);
//                    console.log(col);
//                    console.log(q);
//                    if (row === tunnelStart.x && col === tunnelStart.y - 1) {
//                        row = tunnelEnd.x;
//                        col = tunnelEnd.y;
//                    }
//                    else if (row === tunnelEnd.x && col === tunnelEnd.y + 1) {
//                        row = tunnelStart.x;
//                        col = tunnelStart.y;
//                    }
//                    visited[row][col] = 1;
//                    var adjCell = {pt: {x: row, y: col}, dist: curr.dist + 1};
//                    q.enqueue(adjCell);
//                    console.log(q);
//                }
            }
        }

        return -1;// if destination cannot be reached
    }

    function moveBlinky(matrix, matrixCopy, currentPos, pacmanPos, blinkyMotionDirection) {
        if(currentPos.x === pacmanPos.x && currentPos.y === pacmanPos.y) {
            clearInterval(pacmanInterval);
            clearInterval(blinkyInterval);
            b.innerHTML = "<h1>Game Over</h1>";
        }
        var pathToPacman = [];
        findPath(matrix, currentPos, pacmanPos, pathToPacman, blinkyMotionDirection);
        console.log(pathToPacman, currentPos);
        matrixCopy[pathToPacman[0].x][pathToPacman[0].y] = matrix[pathToPacman[0].x][pathToPacman[0].y];
        matrixCopy[pathToPacman[1].x][pathToPacman[1].y] = 'ghost';
        drawLevelParts(matrixCopy[pathToPacman[0].x][pathToPacman[0].y], {x: pathToPacman[0].x, y: pathToPacman[0].y});
        drawLevelParts(matrixCopy[pathToPacman[1].x][pathToPacman[1].y], {x: pathToPacman[1].x, y: pathToPacman[1].y});

        blinkyMotionDirection.x = pathToPacman[1].x - pathToPacman[0].x;
        // blinkyMotionDirection.y equals 1 => going right, blinkyMotionDirection.y equals -1 => going left, blinkyMotionDirection.y equals 0 => no change in 'y' direction
        blinkyMotionDirection.y = pathToPacman[1].y - pathToPacman[0].y;

        if(pathToPacman.length === 1)
            return "gameOver";
        currentPos.x = pathToPacman[1].x;
        currentPos.y = pathToPacman[1].y;

    }

    function movePacman(matrix, matrixCopy, pacmanPos, blinkyPos) {
        if(blinkyPos.x === pacmanPos.x && blinkyPos.y === pacmanPos.y) {
            clearInterval(pacmanInterval);
            clearInterval(blinkyInterval);
            b.innerHTML = "<h1>Game Over</h1>";
        }
        if(pacmanPos.x + pacmanDirection.x >= 0 && pacmanPos.x + pacmanDirection.x < ROW_MAX && pacmanPos.y + pacmanDirection.y === -1) {
            matrix[pacmanPos.x][pacmanPos.y] = 'ze';
            matrixCopy[pacmanPos.x][pacmanPos.y] = 'ze';
            drawLevelParts(matrixCopy[pacmanPos.x][pacmanPos.y], pacmanPos);
            pacmanPos.y = COL_MAX-1;
            matrixCopy[pacmanPos.x][pacmanPos.y] = 'pacman';
            drawLevelParts(matrixCopy[pacmanPos.x][pacmanPos.y], pacmanPos);
        }
        else if(pacmanPos.x + pacmanDirection.x >= 0 && pacmanPos.x + pacmanDirection.x < ROW_MAX && pacmanPos.y + pacmanDirection.y === COL_MAX) {
            matrix[pacmanPos.x][pacmanPos.y] = 'ze';
            matrixCopy[pacmanPos.x][pacmanPos.y] = 'ze';
            drawLevelParts(matrixCopy[pacmanPos.x][pacmanPos.y], pacmanPos);
            pacmanPos.y = 0;
            matrixCopy[pacmanPos.x][pacmanPos.y] = 'pacman';
            drawLevelParts(matrixCopy[pacmanPos.x][pacmanPos.y], pacmanPos);
        }
        else if (pacmanPos.x + pacmanDirection.x >= 0 && pacmanPos.x + pacmanDirection.x < ROW_MAX && pacmanPos.y + pacmanDirection.y >= 0 && pacmanPos.y + pacmanDirection.y < COL_MAX && (matrix[pacmanPos.x + pacmanDirection.x][pacmanPos.y + pacmanDirection.y] === 'pp' || matrix[pacmanPos.x + pacmanDirection.x][pacmanPos.y + pacmanDirection.y] === 'PP' || matrix[pacmanPos.x + pacmanDirection.x][pacmanPos.y + pacmanDirection.y] === 'ze')) {
            matrix[pacmanPos.x][pacmanPos.y] = 'ze';
            matrixCopy[pacmanPos.x][pacmanPos.y] = 'ze';
            drawLevelParts(matrixCopy[pacmanPos.x][pacmanPos.y], pacmanPos);
            pacmanPos.x += pacmanDirection.x;
            pacmanPos.y += pacmanDirection.y;
            matrixCopy[pacmanPos.x][pacmanPos.y] = 'pacman';
            drawLevelParts(matrixCopy[pacmanPos.x][pacmanPos.y], pacmanPos);
        }
    }

    function drawLevelParts(classAtPos, pos) {
        var posDiv = document.getElementById(pos.x + '_' + pos.y);
        if(posDiv === null) {
            var ijkl = document.getElementsByClassName('ijkl')[0];
            ijkl.innerHTML += "<div class=\"" + classAtPos + "\" id=\"" + pos.x + "_" + pos.y + "\"></div>";
            return;
        }
        posDiv.removeAttribute("class");
        posDiv.setAttribute("class", classAtPos);
    }

    function main() {
        var i, j;

        var blinkyPos = {x: 14, y: 7};//15, 13
        var blinkyMotionDirection = {x: -1, y: 0};
        var pacmanPos = {x: 14, y: 20};//26, 15

        matrix = levelGenerator(1);
        var matrixCopy = levelGenerator(1);
        matrixCopy[pacmanPos.x][pacmanPos.y] = 'pacman';

        for(i = 0; i < ROW_MAX; i++)
        {
            for(j = 0; j < COL_MAX; j++) {
                drawLevelParts(matrixCopy[i][j], {x: i, y: j});
            }
        }


        pacmanChangeDirection(matrix, pacmanPos, blinkyPos);
        pacmanInterval = setInterval(function() {
            movePacman(matrix, matrixCopy, pacmanPos, blinkyPos);
        }, pacmanSpeed);
        blinkyInterval = setInterval(function() {
//            console.log(blinkyMotionDirection.x, " && ", blinkyMotionDirection.y);
            moveBlinky(matrix, matrixCopy, blinkyPos, pacmanPos, blinkyMotionDirection);
            if(blinkyPos === "gameOver") {
                clearInterval(pacmanInterval);
                clearInterval(blinkyInterval);
                b.innerHTML = "<h1>Game Over</h1>";
            }
        }, blinkySpeed);
    }

    function pacmanChangeDirection(matrix, pacmanPos, blinkyPos) {
        var map = {}; // You could also use an array
        onkeydown = onkeyup = function(event) {
            event = event || event; // to deal with IE
            map[event.keyCode] = event.type === 'keydown';
            if (map[37] === true || map[38] === true || map[39] === true || map[40] === true) {
                if(blinkyPos.x === pacmanPos.x && blinkyPos.y === pacmanPos.y) {
                    clearInterval(pacmanInterval);
                    clearInterval(blinkyInterval);
                    b.innerHTML = "<h1>Game Over</h1>";
                }
                if (map[38] === true) {
                    if (pacmanPos.x - 1 >= 0 && pacmanPos.x - 1 < ROW_MAX && pacmanPos.y >= 0 && pacmanPos.y < COL_MAX && (matrix[pacmanPos.x - 1][pacmanPos.y] === 'pp' || matrix[pacmanPos.x - 1][pacmanPos.y] === 'PP' || matrix[pacmanPos.x - 1][pacmanPos.y] === 'ze'))
                        pacmanDirection = {x: -1, y: 0};
                }
                if (map[37] === true) {
                    if (pacmanPos.x >= 0 && pacmanPos.x < ROW_MAX && pacmanPos.y - 1 >= 0 && pacmanPos.y - 1 < COL_MAX && (matrix[pacmanPos.x][pacmanPos.y - 1] === 'pp' || matrix[pacmanPos.x][pacmanPos.y - 1] === 'PP' || matrix[pacmanPos.x][pacmanPos.y - 1] === 'ze'))
                        pacmanDirection = {x: 0, y: -1};
                }
                if (map[40] === true) {
                    console.log("left");
                    if (pacmanPos.x + 1 >= 0 && pacmanPos.x + 1 < ROW_MAX && pacmanPos.y >= 0 && pacmanPos.y < COL_MAX && (matrix[pacmanPos.x + 1][pacmanPos.y] === 'pp' || matrix[pacmanPos.x + 1][pacmanPos.y] === 'PP' || matrix[pacmanPos.x + 1][pacmanPos.y] === 'ze')) {
                        console.log("down");
                        pacmanDirection = {x: 1, y: 0};
                    }
                }
                if (map[39] === true) {
                    if (pacmanPos.x >= 0 && pacmanPos.x < ROW_MAX && pacmanPos.y + 1 >= 0 && pacmanPos.y + 1 < COL_MAX && (matrix[pacmanPos.x][pacmanPos.y + 1] === 'pp' || matrix[pacmanPos.x][pacmanPos.y + 1] === 'PP' || matrix[pacmanPos.x][pacmanPos.y + 1] === 'ze'))
                        pacmanDirection = {x: 0, y: 1};
                }
            }
        };
    }
    main();
</script>
</html>
