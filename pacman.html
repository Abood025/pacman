<!DOCTYPE html>
<html>
<head>
    <title></title>
    <link rel="stylesheet" type="text/css" href="pacman.css">
</head>
<body>
<div class="ijkl"></div>
</body>

<script type="text/javascript">

    str = "";
    b = document.getElementsByTagName("body")[0];
    ROW_MAX = 31;
    COL_MAX = 28;
    blinkySpeed = 1000;
    pacmanSpeed = 100;

    class Queue {
        constructor() {
            this.items = [];
        }
        isEmpty() {
            return this.items.length == 0;
        }
        enqueue(elements) {
            this.items.push(elements);
        }
        dequeue() {
            if(this.isEmpty())
                return "Underflow";
            return this.items.shift();
        }
        front() {
            if(this.isEmpty())
                return "No elements in Queue";
            return this.items[0];
        }
        printQueue() {
            var str = "";
            for(var i = 0; i < this.items.length; i++)
                str += "(" + this.items[0].pt.x.toString() + ", " + this.items[0].pt.y.toString() + "), " + this.items[0].dist + "; ";
            return str;
        }
    }

    function levelGenerator(level) {
        if(level == 1) {
            return ([
                ['B1', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'E7', 'E1', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B7'],
                ['B6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'b2', 'b6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'B2'],
                ['B6', 'pp', 'b1', 'b8', 'b8', 'b7', 'pp', 'b1', 'b8', 'b8', 'b8', 'b7', 'pp', 'b2', 'b6', 'pp', 'b1', 'b8', 'b8', 'b8', 'b7', 'pp', 'b1', 'b8', 'b8', 'b7', 'pp', 'B2'],
                ['B6', 'PP', 'b2', 'ze', 'ze', 'b6', 'pp', 'b2', 'ze', 'ze', 'ze', 'b6', 'pp', 'b2', 'b6', 'pp', 'b2', 'ze', 'ze', 'ze', 'b6', 'pp', 'b2', 'ze', 'ze', 'b6', 'PP', 'B2'],
                ['B6', 'pp', 'b3', 'b4', 'b4', 'b5', 'pp', 'b3', 'b4', 'b4', 'b4', 'b5', 'pp', 'b3', 'b5', 'pp', 'b3', 'b4', 'b4', 'b4', 'b5', 'pp', 'b3', 'b4', 'b4', 'b5', 'pp', 'B2'],
                ['B6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'B2'],
                ['B6', 'pp', 'b1', 'b8', 'b8', 'b7', 'pp', 'b1', 'b7', 'pp', 'b1', 'b8', 'b8', 'b8', 'b8', 'b8', 'b8', 'b7', 'pp', 'b1', 'b7', 'pp', 'b1', 'b8', 'b8', 'b7', 'pp', 'B2'],
                ['B6', 'pp', 'b3', 'b4', 'b4', 'b5', 'pp', 'b2', 'b6', 'pp', 'b3', 'b4', 'b4', 'b7', 'b1', 'b4', 'b4', 'b5', 'pp', 'b2', 'b6', 'pp', 'b3', 'b4', 'b4', 'b5', 'pp', 'B2'],
                ['B6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'b2', 'b6', 'pp', 'pp', 'pp', 'pp', 'b2', 'b6', 'pp', 'pp', 'pp', 'pp', 'b2', 'b6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'B2'],
                ['B3', 'B8', 'B8', 'B8', 'B8', 'b7', 'pp', 'b2', 'b6', 'b1', 'b8', 'b7', 'pp', 'b2', 'b6', 'pp', 'b1', 'b8', 'b7', 'b2', 'b6', 'pp', 'b1', 'B8', 'B8', 'B8', 'B8', 'B5'],
                ['ze', 'ze', 'ze', 'ze', 'ze', 'B6', 'pp', 'b2', 'b6', 'b3', 'b4', 'b5', 'pp', 'b3', 'b5', 'pp', 'b3', 'b4', 'b5', 'b2', 'b6', 'pp', 'B2', 'ze', 'ze', 'ze', 'ze', 'ze'],
                ['ze', 'ze', 'ze', 'ze', 'ze', 'B6', 'pp', 'b2', 'b6', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'b2', 'b6', 'pp', 'B2', 'ze', 'ze', 'ze', 'ze', 'ze'],
                ['ze', 'ze', 'ze', 'ze', 'ze', 'B6', 'pp', 'b2', 'b6', 'ze', 'H1', 'B8', 'L8', 'H8', 'H8', 'R8', 'B8', 'H7', 'ze', 'b2', 'b6', 'pp', 'B2', 'ze', 'ze', 'ze', 'ze', 'ze'],
                ['B4', 'B4', 'B4', 'B4', 'B4', 'b5', 'pp', 'b3', 'b5', 'ze', 'B2', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'B6', 'ze', 'b3', 'b5', 'pp', 'b3', 'B4', 'B4', 'B4', 'B4', 'B4'],
                ['ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'pp', 'ze', 'ze', 'ze', 'B2', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'B6', 'ze', 'ze', 'ze', 'pp', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze'],
                ['B8', 'B8', 'B8', 'B8', 'B8', 'b7', 'pp', 'b1', 'b7', 'ze', 'B2', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'B6', 'ze', 'b1', 'b7', 'pp', 'b1', 'B8', 'B8', 'B8', 'B8', 'B8'],
                ['ze', 'ze', 'ze', 'ze', 'ze', 'B6', 'pp', 'b2', 'b6', 'ze', 'H3', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'H5', 'ze', 'b2', 'b6', 'pp', 'B2', 'ze', 'ze', 'ze', 'ze', 'ze'],
                ['ze', 'ze', 'ze', 'ze', 'ze', 'B6', 'pp', 'b2', 'b6', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'b2', 'b6', 'pp', 'B2', 'ze', 'ze', 'ze', 'ze', 'ze'],
                ['ze', 'ze', 'ze', 'ze', 'ze', 'B6', 'pp', 'b2', 'b6', 'ze', 'b1', 'b8', 'b8', 'b8', 'b8', 'b8', 'b8', 'b7', 'ze', 'b2', 'b6', 'pp', 'B2', 'ze', 'ze', 'ze', 'ze', 'ze'],
                ['B1', 'B4', 'B4', 'B4', 'B4', 'b5', 'pp', 'b3', 'b5', 'ze', 'b3', 'b4', 'b4', 'b7', 'b1', 'b4', 'b4', 'b5', 'ze', 'b3', 'b5', 'pp', 'b3', 'B4', 'B4', 'B4', 'B4', 'B7'],
                ['B6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'b2', 'b6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'B2'],
                ['B6', 'pp', 'b1', 'b8', 'b8', 'b7', 'pp', 'b1', 'b8', 'b8', 'b8', 'b7', 'pp', 'b2', 'b6', 'pp', 'b1', 'b8', 'b8', 'b8', 'b7', 'pp', 'b1', 'b8', 'b8', 'b7', 'pp', 'B2'],
                ['B6', 'pp', 'b3', 'b4', 'b7', 'b6', 'pp', 'b3', 'b4', 'b4', 'b4', 'b5', 'pp', 'b3', 'b5', 'pp', 'b3', 'b4', 'b4', 'b4', 'b5', 'pp', 'b2', 'b1', 'b4', 'b5', 'pp', 'B2'],
                ['B6', 'PP', 'pp', 'pp', 'b2', 'b6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'b2', 'b6', 'pp', 'pp', 'PP', 'B2'],
                ['E3', 'b8', 'b7', 'pp', 'b2', 'b6', 'pp', 'b1', 'b7', 'pp', 'b1', 'b8', 'b8', 'b8', 'b8', 'b8', 'b8', 'b7', 'pp', 'b1', 'b7', 'pp', 'b2', 'b6', 'pp', 'b1', 'b8', 'E5'],
                ['C8', 'b4', 'b5', 'pp', 'b3', 'b5', 'pp', 'b2', 'b6', 'pp', 'b3', 'b4', 'b4', 'b7', 'b1', 'b4', 'b4', 'b5', 'pp', 'b2', 'b6', 'pp', 'b3', 'b5', 'pp', 'b3', 'b4', 'C9'],
                ['B6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'b2', 'b6', 'pp', 'pp', 'pp', 'pp', 'b2', 'b6', 'pp', 'pp', 'pp', 'pp', 'b2', 'b6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'B2'],
                ['B6', 'pp', 'b1', 'b8', 'b8', 'b8', 'b8', 'b5', 'b3', 'b8', 'b8', 'b7', 'pp', 'b2', 'b6', 'pp', 'b1', 'b8', 'b8', 'b5', 'b3', 'b8', 'b8', 'b8', 'b8', 'b7', 'pp', 'B2'],
                ['B6', 'pp', 'b3', 'b4', 'b4', 'b4', 'b4', 'b4', 'b4', 'b4', 'b4', 'b5', 'pp', 'b3', 'b5', 'pp', 'b3', 'b4', 'b4', 'b4', 'b4', 'b4', 'b4', 'b4', 'b4', 'b5', 'pp', 'B2'],
                ['B6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'B2'],
                ['B3', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B5']
            ]);
        }
    }
    function generateVisited() {
        var visited = [], temp = [], i, j;
        for(i = 0; i < ROW_MAX; i++)
        {
            temp = [];
            for(j = 0; j < COL_MAX; j++)
                temp.push(0);
            visited[i] = temp;
        }
        return visited;
    }

    function isValid(row, col)
    {
        // return true if row pacmanInterval and column pacmanInterval is in range
        return ((row >= 0) && (row < ROW_MAX) && (col >= 0) && (col < COL_MAX));
    }

    // These arrays are used to get row and column
    // pacmanIntervals of 4 neighbours of a given cell
    rowNum = [-1, 0, 0, 1];
    colNum = [0, -1, 1, 0];

    function findPath(matrix, blinkyPos, pacmanPos, pathToPacman, blinkyMotionDirection) {
        // check source and destination cell
        // of the matrix have value 1
        if (!(matrix[blinkyPos.x][blinkyPos.y] == 'H8' || matrix[blinkyPos.x][blinkyPos.y] == 'ze' || matrix[pacmanPos.x][pacmanPos.y] == 'ze' || matrix[blinkyPos.x][blinkyPos.y] == 'pp' || matrix[pacmanPos.x][pacmanPos.y] == 'pp' || matrix[blinkyPos.x][blinkyPos.y] == 'PP' || matrix[pacmanPos.x][pacmanPos.y] == 'PP')) {
            return -1;
        }

//        bool visited[ROW][COL];
//        memset(visited, false, sizeof visited);
        var visited = generateVisited();

        // Mark the source cell as visited
        visited[blinkyPos.x][blinkyPos.y] = 1;

        // Create a queue for BFS
        var q = new Queue();

        // distance of source cell is 0
        var s = {pt: blinkyPos, dist: 0};
        q.enqueue(s);  // Enqueue source cell

        var count = 0, str3 = "", temp = [];
        // Do a BFS starting from source cell
        while (q.isEmpty() !== true)
        {
            var curr = q.front();
            var pt = curr.pt;

            temp[count++] = curr;
//            console.log(q.printQueue())
//            console.log(pathToPacman[count-1].printQueue());
            // If we have reached the destination cell,
            // we are done
            if (pt.x == pacmanPos.x && pt.y == pacmanPos.y) {
//                for(var k = 0; k < temp.length; k++)
//                    str3 += "(" + temp[k].pt.x.toString() + ", " + temp[k].pt.y.toString() + "), " + temp[k].dist + "; ";
//
//                str3 += "<br><br><br><br>";
                var earlierPoint = temp[temp.length - 1];
                for(var l = temp.length - 2; l >= 0; l--) {
                    if((temp[l].pt.x == earlierPoint.pt.x && Math.abs(temp[l].pt.y - earlierPoint.pt.y) == 1) || (temp[l].pt.y == earlierPoint.pt.y && Math.abs(temp[l].pt.x - earlierPoint.pt.x) == 1)) {
                        pathToPacman.push(temp[l].pt);
                        earlierPoint = temp[l];
//                        str3 += "(" + temp[l].pt.x.toString() + ", " + temp[l].pt.y.toString() + "), " + temp[l].dist + "; ";
                    }
                }
//                b.innerHTML += str3;
                pathToPacman = pathToPacman.reverse();
                pathToPacman.push(pacmanPos);
//                console.log(pathToPacman);

                return curr.dist;
            }

            // Otherwise dequeue the front cell in the queue
            // and enqueue its adjacent cells
            q.dequeue();

            for (var i = 0; i < 4; i++)
            {
                if(count == 1 && blinkyMotionDirection.x == -1 * rowNum[i] && blinkyMotionDirection.y == -1 * colNum[i])
                    continue;
                var row = pt.x + rowNum[i];
                var col = pt.y + colNum[i];

                // if adjacent cell is valid, has path and
                // not visited yet, enqueue it.
                if (isValid(row, col) == true && (matrix[row][col] == 'pp' || matrix[row][col] == 'PP' || matrix[row][col] == 'H8' || matrix[row][col] == 'ze') && visited[row][col] == 0)
                {
                    // mark cell as visited and enqueue it
                    visited[row][col] = 1;
                    var adjCell = {pt: {x: row, y: col}, dist: curr.dist + 1};
                    q.enqueue(adjCell);
                }
            }
        }

        return -1;// if destination cannot be reached
    }

    function moveBlinky(matrix, matrixCopy, currentPos, pacmanPos, blinkyMotionDirection) {
        if(currentPos.x == pacmanPos.x && currentPos.y == pacmanPos.y) {
            clearInterval(pacmanInterval);
            clearInterval(blinkyInterval);
            b.innerHTML = "<h1>Game Over</h1>";
        }
        var temp, pathToPacman = [];
        findPath(matrix, currentPos, pacmanPos, pathToPacman, blinkyMotionDirection);
        matrixCopy[pathToPacman[0].x][pathToPacman[0].y] = matrix[pathToPacman[0].x][pathToPacman[0].y];
        matrixCopy[pathToPacman[1].x][pathToPacman[1].y] = 'ghost';

        blinkyMotionDirection.x = pathToPacman[1].x - pathToPacman[0].x;
        // blinkyMotionDirection.y equals 1 => going right, blinkyMotionDirection.y equals -1 => going left, blinkyMotionDirection.y equals 0 => no change in 'y' direction
        blinkyMotionDirection.y = pathToPacman[1].y - pathToPacman[0].y;

        if(pathToPacman.length == 1)
            return "gameOver";
        currentPos.x = pathToPacman[1].x;
        currentPos.y = pathToPacman[1].y;

        return currentPos;
    }

    function movePacman(matrix, matrixCopy, pacmanPos, blinkyPos, pacmanDirection) {
        var map = {};
        console.log(pacmanDirection);
        onkeydown = onkeyup = function(event) {
            event = event || event;
            map[event.keyCode] = event.type == 'keydown';
            if (map[37] == true || map[38] == true || map[39] == true || map[40] == true) {
                if(blinkyPos.x == pacmanPos.x && blinkyPos.y == pacmanPos.y) {
                    clearInterval(pacmanInterval);
                    clearInterval(blinkyInterval);
                    b.innerHTML = "<h1>Game Over</h1>";
                }
                if (map[38] == true) {
                    if (pacmanPos.x - 1 >= 0 && pacmanPos.x - 1 < ROW_MAX && pacmanPos.y >= 0 && pacmanPos.y < COL_MAX && (matrix[pacmanPos.x - 1][pacmanPos.y] == 'pp' || matrix[pacmanPos.x - 1][pacmanPos.y] == 'PP' || matrix[pacmanPos.x - 1][pacmanPos.y] == 'ze')) {
                        matrix[pacmanPos.x][pacmanPos.y] = 'ze';
                        matrixCopy[pacmanPos.x][pacmanPos.y] = 'ze';
                        matrixCopy[--pacmanPos.x][pacmanPos.y] = 'ghost';
                        pacmanDirection = {x: -1, y: 0};
                    }
                }
                if (map[37] == true) {
                    if (pacmanPos.x >= 0 && pacmanPos.x < ROW_MAX && pacmanPos.y - 1 >= 0 && pacmanPos.y - 1 < COL_MAX && (matrix[pacmanPos.x][pacmanPos.y - 1] == 'pp' || matrix[pacmanPos.x][pacmanPos.y - 1] == 'PP' || matrix[pacmanPos.x][pacmanPos.y - 1] == 'ze')) {
                        matrix[pacmanPos.x][pacmanPos.y] = 'ze';
                        matrixCopy[pacmanPos.x][pacmanPos.y] = 'ze';
                        matrixCopy[pacmanPos.x][--pacmanPos.y] = 'ghost';
                        pacmanDirection = {x: 0, y: -1};
                    }
                }
                if (map[40] == true) {
                    if (pacmanPos.x + 1 >= 0 && pacmanPos.x + 1 < ROW_MAX && pacmanPos.y >= 0 && pacmanPos.y < COL_MAX && (matrix[pacmanPos.x + 1][pacmanPos.y] == 'pp' || matrix[pacmanPos.x + 1][pacmanPos.y] == 'PP' || matrix[pacmanPos.x + 1][pacmanPos.y] == 'ze')) {
                        matrix[pacmanPos.x][pacmanPos.y] = 'ze';
                        matrixCopy[pacmanPos.x][pacmanPos.y] = 'ze';
                        matrixCopy[++pacmanPos.x][pacmanPos.y] = 'ghost';
                        pacmanDirection = {x: 1, y: 0};
                    }
                }
                if (map[39] == true) {
                    if (pacmanPos.x >= 0 && pacmanPos.x < ROW_MAX && pacmanPos.y + 1 >= 0 && pacmanPos.y + 1 < COL_MAX && (matrix[pacmanPos.x][pacmanPos.y + 1] == 'pp' || matrix[pacmanPos.x][pacmanPos.y + 1] == 'PP' || matrix[pacmanPos.x][pacmanPos.y + 1] == 'ze')) {
                        matrix[pacmanPos.x][pacmanPos.y] = 'ze';
                        matrixCopy[pacmanPos.x][pacmanPos.y] = 'ze';
                        matrixCopy[pacmanPos.x][++pacmanPos.y] = 'ghost';
                        pacmanDirection = {x: 0, y: 1};
                    }
                }
            }
        };
        console.log(map);
        if(map[37] == false && map[38] == false && map[39] == false && map[40] == false) {
            matrix[pacmanPos.x][pacmanPos.y] = 'ze';
            matrixCopy[pacmanPos.x][pacmanPos.y] = 'ze';
            matrixCopy[pacmanPos.x + pacmanDirection.x][pacmanPos.y + pacmanDirection.y] = "ghost";
        }
        for(var i = 0; i < ROW_MAX; i++)
        {
            for(var j = 0; j < COL_MAX; j++)
                drawLevelParts(matrixCopy[i][j], {x: i, y: j});
        }
    }

    function drawLevelParts(classAtPos, pos) {
        var posDiv = document.getElementById(pos.x + '_' + pos.y);
        if(posDiv == undefined) {
            var ijkl = document.getElementsByClassName('ijkl')[0];
            ijkl.innerHTML += "<div class=\"" + classAtPos + "\"id=\"" + pos.x + "_" + pos.y + "\"></div>";
            return;
        }
        posDiv.removeAttribute("class");
        posDiv.setAttribute("class", classAtPos);
    }

    function main() {
        var i, j;

        var blinkyPos = {x: 15, y: 13};
        var pacmanPos = {x: 26, y: 15};

        var matrix = levelGenerator(1);
        var matrixCopy = levelGenerator(1);
        matrixCopy[pacmanPos.x][pacmanPos.y] = 'ghost';

        pacmanInterval = setInterval(function() {
            movePacman(matrix, matrixCopy, pacmanPos, blinkyPos, pacmanDirection);
        }, pacmanSpeed);
        var blinkyMotionDirection = {x: -1, y: 0};
        var pacmanDirection = {x: -1, y: 0};
        blinkyInterval = setInterval(function() {
            console.log(blinkyMotionDirection.x, " && ", blinkyMotionDirection.y);
            blinkyPos = moveBlinky(matrix, matrixCopy, blinkyPos, pacmanPos, blinkyMotionDirection);
            if(blinkyPos == "gameOver") {
                clearInterval(pacmanInterval);
                clearInterval(blinkyInterval);
                b.innerHTML = "<h1>Game Over</h1>";
            }
        }, blinkySpeed);
    }
    main();

</script>
</html>