<!DOCTYPE html>
<html>
<head>
    <title></title>
    <link rel="stylesheet" type="text/css" href="pacman.css">
</head>
<body>
<div class="ijkl"></div>
</body>

<script type="text/javascript">

    str = "";
    b = document.getElementsByTagName("body")[0];
    ROW_MAX = 31;
    COL_MAX = 28;
    pacmanSpeed = 160;
    pacmanDirection = {x: 1, y: 0};
    tunnelStart = {x:14 ,y: 0};
    tunnelEnd = {x:14 ,y: 27};
    window.pacmanMouthAngle = 360;


    class Queue {
        constructor() {
            this.items = [];
        }
        isEmpty() {
            return this.items.length === 0;
        }
        enqueue(elements) {
            this.items.push(elements);
        }
        dequeue() {
            if(this.isEmpty())
                return "Underflow";
            return this.items.shift();
        }
        front() {
            if(this.isEmpty())
                return "No elements in Queue";
            return this.items[0];
        }
        printQueue() {
            var str = "";
            for(var i = 0; i < this.items.length; i++)
                str += "(" + this.items[0].pt.x.toString() + ", " + this.items[0].pt.y.toString() + "), " + this.items[0].dist + "; ";
            return str;
        }
    }

    class Ghost {
        constructor() {
            this.name = "";
            this.direction = {};
            this.position = {};
            this.classActive = "";
            this.speed = 500;
        }
        findPathToPacman() {

        }
        move(matrix, matrixCopy, pacmanPos/*, ghost2, ghost3, ghost4*/) {
            if((this.position.x === pacmanPos.x && this.position.y === pacmanPos.y)/* || (inkyPos.x === pacmanPos.x && inkyPos.y === pacmanPos.y)*/) {
                clearInterval(pacmanInterval);
                clearInterval(blinkyInterval);
//                clearInterval(inkyInterval);
                b.innerHTML = "<h1>Game Over</h1>";
            }
            var pathToPacman = [];
            findPath(matrix, this.position, pacmanPos, pathToPacman, this.direction/*, inkyPos*/);
            // direction.y equals 1 => going right, direction.y equals -1 => going left, direction.y equals 0 => no change in 'y' direction
            this.setDirection(pathToPacman[1].x - pathToPacman[0].x, pathToPacman[1].y - pathToPacman[0].y);
            matrixCopy[pathToPacman[0].x][pathToPacman[0].y] = matrix[pathToPacman[0].x][pathToPacman[0].y];
            matrixCopy[pathToPacman[1].x][pathToPacman[1].y] = this.classActive;
            drawLevelParts(matrixCopy[pathToPacman[0].x][pathToPacman[0].y], {x: pathToPacman[0].x, y: pathToPacman[0].y});
            drawLevelParts(matrixCopy[pathToPacman[1].x][pathToPacman[1].y], {x: pathToPacman[1].x, y: pathToPacman[1].y});

            if(pathToPacman.length === 1)
                return "gameOver";
            this.position.x = pathToPacman[1].x;
            this.position.y = pathToPacman[1].y;
        }
        setDirection(x, y) {
            this.direction.x = x;
            this.direction.y = y;
            if(x === -1 && y === 0)
                this.classActive = this.name + "Up1";
            else if(x === 1 && y === 0)
                this.classActive = this.name + "Down1";
            else if(x === 0 && y === -1)
                this.classActive = this.name + "Left1";
            else if(x === 0 && y === 1)
                this.classActive = this.name + "Right1";
        }
        setPos(x, y) {
            this.position.x = x;
            this.position.y = y;
        }
        setSpeed(speed) {
            this.speed = speed;
        }
        setName(name) {
            this.name = name;
        }
        getDirection() {
            return this.direction;
        }
        getPos() {
            return this.position;
        }
        getClass() {
            return this.classActive;
        }
        getSpeed() {
            return this.speed;
        }
    }


    function levelGenerator(level) {
        if(level === 1) {
            return ([
                ['B1', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'E7', 'E1', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'B7'],
                ['B6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'b2', 'b6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'B2'],
                ['B6', 'pp', 'b1', 'b8', 'b8', 'b7', 'pp', 'b1', 'b8', 'b8', 'b8', 'b7', 'pp', 'b2', 'b6', 'pp', 'b1', 'b8', 'b8', 'b8', 'b7', 'pp', 'b1', 'b8', 'b8', 'b7', 'pp', 'B2'],
                ['B6', 'PP', 'b2', 'ze', 'ze', 'b6', 'pp', 'b2', 'ze', 'ze', 'ze', 'b6', 'pp', 'b2', 'b6', 'pp', 'b2', 'ze', 'ze', 'ze', 'b6', 'pp', 'b2', 'ze', 'ze', 'b6', 'PP', 'B2'],
                ['B6', 'pp', 'b3', 'b4', 'b4', 'b5', 'pp', 'b3', 'b4', 'b4', 'b4', 'b5', 'pp', 'b3', 'b5', 'pp', 'b3', 'b4', 'b4', 'b4', 'b5', 'pp', 'b3', 'b4', 'b4', 'b5', 'pp', 'B2'],
                ['B6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'B2'],
                ['B6', 'pp', 'b1', 'b8', 'b8', 'b7', 'pp', 'b1', 'b7', 'pp', 'b1', 'b8', 'b8', 'b8', 'b8', 'b8', 'b8', 'b7', 'pp', 'b1', 'b7', 'pp', 'b1', 'b8', 'b8', 'b7', 'pp', 'B2'],
                ['B6', 'pp', 'b3', 'b4', 'b4', 'b5', 'pp', 'b2', 'b6', 'pp', 'b3', 'b4', 'b4', 'b7', 'b1', 'b4', 'b4', 'b5', 'pp', 'b2', 'b6', 'pp', 'b3', 'b4', 'b4', 'b5', 'pp', 'B2'],
                ['B6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'b2', 'b6', 'pp', 'pp', 'pp', 'pp', 'b2', 'b6', 'pp', 'pp', 'pp', 'pp', 'b2', 'b6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'B2'],
                ['B3', 'B8', 'B8', 'B8', 'B8', 'b7', 'pp', 'b2', 'b3', 'b8', 'b8', 'b7', 'pp', 'b2', 'b6', 'pp', 'b1', 'b8', 'b8', 'b5', 'b6', 'pp', 'b1', 'B8', 'B8', 'B8', 'B8', 'B5'],
                ['ze', 'ze', 'ze', 'ze', 'ze', 'B6', 'pp', 'b2', 'b1', 'b4', 'b4', 'b5', 'pp', 'b3', 'b5', 'pp', 'b3', 'b4', 'b4', 'b7', 'b6', 'pp', 'B2', 'ze', 'ze', 'ze', 'ze', 'ze'],
                ['ze', 'ze', 'ze', 'ze', 'ze', 'B6', 'pp', 'b2', 'b6', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'b2', 'b6', 'pp', 'B2', 'ze', 'ze', 'ze', 'ze', 'ze'],
                ['ze', 'ze', 'ze', 'ze', 'ze', 'B6', 'pp', 'b2', 'b6', 'ze', 'H1', 'B8', 'L8', 'H8', 'H8', 'R8', 'B8', 'H7', 'ze', 'b2', 'b6', 'pp', 'B2', 'ze', 'ze', 'ze', 'ze', 'ze'],
                ['B4', 'B4', 'B4', 'B4', 'B4', 'b5', 'pp', 'b3', 'b5', 'ze', 'B2', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'B6', 'ze', 'b3', 'b5', 'pp', 'b3', 'B4', 'B4', 'B4', 'B4', 'B4'],
                ['ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'pp', 'ze', 'ze', 'ze', 'B2', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'B6', 'ze', 'ze', 'ze', 'pp', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze'],
                ['B8', 'B8', 'B8', 'B8', 'B8', 'b7', 'pp', 'b1', 'b7', 'ze', 'B2', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'B6', 'ze', 'b1', 'b7', 'pp', 'b1', 'B8', 'B8', 'B8', 'B8', 'B8'],
                ['ze', 'ze', 'ze', 'ze', 'ze', 'B6', 'pp', 'b2', 'b6', 'ze', 'H3', 'B4', 'B4', 'B4', 'B4', 'B4', 'B4', 'H5', 'ze', 'b2', 'b6', 'pp', 'B2', 'ze', 'ze', 'ze', 'ze', 'ze'],
                ['ze', 'ze', 'ze', 'ze', 'ze', 'B6', 'pp', 'b2', 'b6', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'ze', 'b2', 'b6', 'pp', 'B2', 'ze', 'ze', 'ze', 'ze', 'ze'],
                ['ze', 'ze', 'ze', 'ze', 'ze', 'B6', 'pp', 'b2', 'b6', 'ze', 'b1', 'b8', 'b8', 'b8', 'b8', 'b8', 'b8', 'b7', 'ze', 'b2', 'b6', 'pp', 'B2', 'ze', 'ze', 'ze', 'ze', 'ze'],
                ['B1', 'B4', 'B4', 'B4', 'B4', 'b5', 'pp', 'b3', 'b5', 'ze', 'b3', 'b4', 'b4', 'b7', 'b1', 'b4', 'b4', 'b5', 'ze', 'b3', 'b5', 'pp', 'b3', 'B4', 'B4', 'B4', 'B4', 'B7'],
                ['B6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'b2', 'b6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'B2'],
                ['B6', 'pp', 'b1', 'b8', 'b8', 'b7', 'pp', 'b1', 'b8', 'b8', 'b8', 'b7', 'pp', 'b2', 'b6', 'pp', 'b1', 'b8', 'b8', 'b8', 'b7', 'pp', 'b1', 'b8', 'b8', 'b7', 'pp', 'B2'],
                ['B6', 'pp', 'b3', 'b4', 'b7', 'b6', 'pp', 'b3', 'b4', 'b4', 'b4', 'b5', 'pp', 'b3', 'b5', 'pp', 'b3', 'b4', 'b4', 'b4', 'b5', 'pp', 'b2', 'b1', 'b4', 'b5', 'pp', 'B2'],
                ['B6', 'PP', 'pp', 'pp', 'b2', 'b6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'b2', 'b6', 'pp', 'pp', 'PP', 'B2'],
                ['E3', 'b8', 'b7', 'pp', 'b2', 'b6', 'pp', 'b1', 'b7', 'pp', 'b1', 'b8', 'b8', 'b8', 'b8', 'b8', 'b8', 'b7', 'pp', 'b1', 'b7', 'pp', 'b2', 'b6', 'pp', 'b1', 'b8', 'E5'],
                ['C8', 'b4', 'b5', 'pp', 'b3', 'b5', 'pp', 'b2', 'b6', 'pp', 'b3', 'b4', 'b4', 'b7', 'b1', 'b4', 'b4', 'b5', 'pp', 'b2', 'b6', 'pp', 'b3', 'b5', 'pp', 'b3', 'b4', 'C9'],
                ['B6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'b2', 'b6', 'pp', 'pp', 'pp', 'pp', 'b2', 'b6', 'pp', 'pp', 'pp', 'pp', 'b2', 'b6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'B2'],
                ['B6', 'pp', 'b1', 'b8', 'b8', 'b8', 'b8', 'b5', 'b3', 'b8', 'b8', 'b7', 'pp', 'b2', 'b6', 'pp', 'b1', 'b8', 'b8', 'b5', 'b3', 'b8', 'b8', 'b8', 'b8', 'b7', 'pp', 'B2'],
                ['B6', 'pp', 'b3', 'b4', 'b4', 'b4', 'b4', 'b4', 'b4', 'b4', 'b4', 'b5', 'pp', 'b3', 'b5', 'pp', 'b3', 'b4', 'b4', 'b4', 'b4', 'b4', 'b4', 'b4', 'b4', 'b5', 'pp', 'B2'],
                ['B6', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'pp', 'B2'],
                ['B3', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B8', 'B5']
            ]);
        }
    }
    function generateVisited() {
        var visited = [], temp = [], i, j;
        for(i = 0; i < ROW_MAX; i++)
        {
            temp = [];
            for(j = 0; j < COL_MAX; j++)
                temp.push(0);
            visited[i] = temp;
        }
        return visited;
    }

    function isValid(row, col)
    {
        // return true if row pacmanInterval and column pacmanInterval is in range
        return ((row >= 0) && (row < ROW_MAX) && (col >= 0) && (col < COL_MAX));
    }

    // These arrays are used to get row and column
    // pacmanIntervals of 4 neighbours of a given cell
    rowNum = [-1, 0, 0, 1];
    colNum = [0, -1, 1, 0];

    function findPath(matrix, blinkyPos, pacmanPos, pathToPacman, blinkyMotionDirection) {
        // check source and destination cell
        // of the matrix have value 1
        if (!(matrix[blinkyPos.x][blinkyPos.y] === 'H8' || matrix[blinkyPos.x][blinkyPos.y] === 'ze' || matrix[pacmanPos.x][pacmanPos.y] === 'ze' || matrix[blinkyPos.x][blinkyPos.y] === 'pp' || matrix[pacmanPos.x][pacmanPos.y] === 'pp' || matrix[blinkyPos.x][blinkyPos.y] === 'PP' || matrix[pacmanPos.x][pacmanPos.y] === 'PP')) {
            return -1;
        }

//        bool visited[ROW][COL];
//        memset(visited, false, sizeof visited);
        var visited = generateVisited();

        // Mark the source cell as visited
        visited[blinkyPos.x][blinkyPos.y] = 1;

        // Create a queue for BFS
        var q = new Queue();

        // distance of source cell is 0
        var s = {pt: blinkyPos, dist: 0};
        q.enqueue(s);  // Enqueue source cell

        var count = 0, str3 = "", temp = [];
        // Do a BFS starting from source cell
        while (q.isEmpty() !== true)
        {
            var curr = q.front();
            var pt = curr.pt;

            temp[count++] = curr;
//            console.log(q.printQueue())
//            console.log(pathToPacman[count-1].printQueue());
            // If we have reached the destination cell,
            // we are done
            if (pt.x === pacmanPos.x && pt.y === pacmanPos.y) {
//                for(var k = 0; k < temp.length; k++)
//                    str3 += "(" + temp[k].pt.x.toString() + ", " + temp[k].pt.y.toString() + "), " + temp[k].dist + "; ";
//
//                str3 += "<br><br><br><br>";
                var earlierPoint = temp[temp.length - 1];
                var correctPathFound = false, l;
                for(l = temp.length - 2; l >= 0; l--) {
                    if((temp[l].pt.x === earlierPoint.pt.x && Math.abs(temp[l].pt.y - earlierPoint.pt.y) === 1) || (temp[l].pt.y === earlierPoint.pt.y && Math.abs(temp[l].pt.x - earlierPoint.pt.x) === 1)) {
                        pathToPacman.push(temp[l].pt);
                        earlierPoint = temp[l];
//                        str3 += "(" + temp[l].pt.x.toString() + ", " + temp[l].pt.y.toString() + "), " + temp[l].dist + "; ";
                    }
                }
//                b.innerHTML += str3;
                pathToPacman = pathToPacman.reverse();
                pathToPacman.push(pacmanPos);

//                if((pacmanPos.x === tunnelStart.x && pacmanPos.y === tunnelStart.y ) || (pacmanPos.x === tunnelEnd.x && pacmanPos.y === tunnelEnd.y )) {
//                    console.log(pathToPacman);
//                    console.log(temp);
//                }

                return curr.dist;
            }

            // Otherwise dequeue the front cell in the queue
            // and enqueue its adjacent cells
            q.dequeue();

            for (var i = 0; i < 4; i++)
            {
                if(count === 1 && blinkyMotionDirection.x === -1 * rowNum[i] && blinkyMotionDirection.y === -1 * colNum[i])
                    continue;
                var row = pt.x + rowNum[i];
                var col = pt.y + colNum[i];
                // if adjacent cell is valid, has path and
                // not visited yet, enqueue it.
                if (isValid(row, col) === true && (matrix[row][col] === 'pp' || matrix[row][col] === 'PP' || matrix[row][col] === 'H8' || matrix[row][col] === 'ze') && visited[row][col] === 0)
                {
                    // mark cell as visited and enqueue it
                    visited[row][col] = 1;
                    var adjCell = {pt: {x: row, y: col}, dist: curr.dist + 1};
                    q.enqueue(adjCell);
                }
            }
        }

        return -1;// if destination cannot be reached
    }

    function movePacman(matrix, matrixCopy, pacmanPos, blinkyPos, inkyPos) {
        if((blinkyPos.x === pacmanPos.x && blinkyPos.y === pacmanPos.y)/* || (inkyPos.x === pacmanPos.x && inkyPos.y === pacmanPos.y)*/) {
            clearInterval(pacmanInterval);
            clearInterval(blinkyInterval);
//            clearInterval(inkyInterval);
            b.innerHTML = "<h1>Game Over</h1>";
        }
        if(pacmanPos.x + pacmanDirection.x >= 0 && pacmanPos.x + pacmanDirection.x < ROW_MAX && pacmanPos.y + pacmanDirection.y === -1) {
            matrix[pacmanPos.x][pacmanPos.y] = 'ze';
            matrixCopy[pacmanPos.x][pacmanPos.y] = 'ze';
            drawLevelParts(matrixCopy[pacmanPos.x][pacmanPos.y], pacmanPos);
            pacmanPos.y = COL_MAX-1;
//            matrixCopy[pacmanPos.x][pacmanPos.y] = 'pacmanLeft';
            drawLevelParts(matrixCopy[pacmanPos.x][pacmanPos.y], pacmanPos);
        }
        else if(pacmanPos.x + pacmanDirection.x >= 0 && pacmanPos.x + pacmanDirection.x < ROW_MAX && pacmanPos.y + pacmanDirection.y === COL_MAX) {
            matrix[pacmanPos.x][pacmanPos.y] = 'ze';
            matrixCopy[pacmanPos.x][pacmanPos.y] = 'ze';
            drawLevelParts(matrixCopy[pacmanPos.x][pacmanPos.y], pacmanPos);
            pacmanPos.y = 0;
//            matrixCopy[pacmanPos.x][pacmanPos.y] = 'pacmanRight';
            drawLevelParts(matrixCopy[pacmanPos.x][pacmanPos.y], pacmanPos);
        }
        else if (pacmanPos.x + pacmanDirection.x >= 0 && pacmanPos.x + pacmanDirection.x < ROW_MAX && pacmanPos.y + pacmanDirection.y >= 0 && pacmanPos.y + pacmanDirection.y < COL_MAX && (matrix[pacmanPos.x + pacmanDirection.x][pacmanPos.y + pacmanDirection.y] === 'pp' || matrix[pacmanPos.x + pacmanDirection.x][pacmanPos.y + pacmanDirection.y] === 'PP' || matrix[pacmanPos.x + pacmanDirection.x][pacmanPos.y + pacmanDirection.y] === 'ze')) {
            matrix[pacmanPos.x][pacmanPos.y] = 'ze';
            matrixCopy[pacmanPos.x][pacmanPos.y] = 'ze';
            drawLevelParts(matrixCopy[pacmanPos.x][pacmanPos.y], pacmanPos);
            pacmanPos.x += pacmanDirection.x;
            pacmanPos.y += pacmanDirection.y;
//            if(pacmanDirection.x === -1 && pacmanDirection.y === 0)
//                matrixCopy[pacmanPos.x][pacmanPos.y] = "pacmanUp315";
//            else if(pacmanDirection.x === 1 && pacmanDirection.y === 0)
//                matrixCopy[pacmanPos.x][pacmanPos.y] = "pacmanDown315";
//            else if(pacmanDirection.x === 0 && pacmanDirection.y === -1)
//                matrixCopy[pacmanPos.x][pacmanPos.y] = "pacmanLeft315";
//            else if(pacmanDirection.x === 0 && pacmanDirection.y === 1)
//                matrixCopy[pacmanPos.x][pacmanPos.y] = "pacmanRight315";
            drawLevelParts(matrixCopy[pacmanPos.x][pacmanPos.y], pacmanPos);
        }
    }

    function drawLevelParts(classAtPos, pos) {
        var posDiv = document.getElementById(pos.x + '_' + pos.y);
        if(posDiv === null) {
            var ijkl = document.getElementsByClassName('ijkl')[0];
            ijkl.innerHTML += "<div class=\"" + classAtPos + "\" id=\"" + pos.x + "_" + pos.y + "\"></div>";
            return;
        }
        posDiv.removeAttribute("class");
        posDiv.setAttribute("class", classAtPos);
    }

    function main() {
        var i, j;

        var blinky = new Ghost();
        blinky.setName("blinky");
        blinky.setPos(15, 13);
        blinky.setDirection(-1, 0);
        blinky.setSpeed(300);

        var inky = new Ghost();
        inky.setName("inky");
        inky.setPos(15, 14);
        inky.setDirection(1, 0);
        inky.setSpeed(300);
//        var inkyPos = {x: 15, y: 15};//15, 13
//        var inkyMotionDirection = {x: 1, y: 0};
        var pacmanPos = {x: 26, y: 15};//26, 15

        matrix = levelGenerator(1);
        var matrixCopy = levelGenerator(1);
        matrixCopy[pacmanPos.x][pacmanPos.y] = 'pacman';

        for(i = 0; i < ROW_MAX; i++)
        {
            for(j = 0; j < COL_MAX; j++) {
                drawLevelParts(matrixCopy[i][j], {x: i, y: j});
            }
        }

        var blinkyPos = blinky.getPos();
        var inkyPos = inky.getPos();

        pacmanChangeDirection(matrix, pacmanPos, blinky.getPos()/*, inkyPos*/);
        window.angleDiff = 45;
        pacmanInterval = setInterval(function() {
            movePacman(matrix, matrixCopy, pacmanPos, blinkyPos);
            if (pacmanMouthAngle >= 360)
                angleDiff = -45;
            else if (pacmanMouthAngle <= 270)
                angleDiff = 45;
            pacmanMouthAngle = pacmanMouthAngle + angleDiff;
            if (pacmanDirection.x === -1 && pacmanDirection.y === 0)
                matrixCopy[pacmanPos.x][pacmanPos.y] = "pacmanUp" + pacmanMouthAngle;
            else if (pacmanDirection.x === 1 && pacmanDirection.y === 0)
                matrixCopy[pacmanPos.x][pacmanPos.y] = "pacmanDown" + pacmanMouthAngle;
            else if (pacmanDirection.x === 0 && pacmanDirection.y === -1)
                matrixCopy[pacmanPos.x][pacmanPos.y] = "pacmanLeft" + pacmanMouthAngle;
            else if (pacmanDirection.x === 0 && pacmanDirection.y === 1)
                matrixCopy[pacmanPos.x][pacmanPos.y] = "pacmanRight" + pacmanMouthAngle;
            drawLevelParts(matrixCopy[pacmanPos.x][pacmanPos.y], pacmanPos);
        }, pacmanSpeed);


        blinkyInterval = setInterval(function() {
            blinky.move(matrix, matrixCopy, pacmanPos);
            if(blinkyPos === "gameOver") {
                clearInterval(pacmanInterval);
                clearInterval(blinkyInterval);
                clearInterval(inkyInterval);
                b.innerHTML = "<h1>Game Over</h1>";
            }
        }, blinky.getSpeed());

        inkyInterval = setInterval(function() {
            inky.move(matrix, matrixCopy, {x: pacmanPos.x + 4*pacmanDirection.x, y: pacmanPos.y + 4*pacmanDirection.y});
            if(inkyPos === "gameOver") {
                clearInterval(pacmanInterval);
                clearInterval(blinkyInterval);
                clearInterval(inkyInterval);
                b.innerHTML = "<h1>Game Over</h1>";
            }
        }, inky.getSpeed());
//        inkyInterval = setInterval(function() {
////            console.log(blinkyMotionDirection.x, " && ", blinkyMotionDirection.y);
//            moveInky(matrix, matrixCopy, inkyPos, pacmanPos, inkyMotionDirection, blinkyPos);
//            if(inkyPos === "gameOver") {
//                clearInterval(pacmanInterval);
//                clearInterval(blinkyInterval);
//                clearInterval(inkyInterval);
//                b.innerHTML = "<h1>Game Over</h1>";
//            }
//        }, blinkySpeed);
    }

    function pacmanChangeDirection(matrix, pacmanPos, blinkyPos, inkyPos) {
        var map = {}; // You could also use an array
        onkeydown = onkeyup = function(event) {
            event = event || event; // to deal with IE
            map[event.keyCode] = event.type === 'keydown';
            if (map[37] === true || map[38] === true || map[39] === true || map[40] === true) {
                if((blinkyPos.x === pacmanPos.x && blinkyPos.y === pacmanPos.y)/* || (inkyPos.x === pacmanPos.x && inkyPos.y === pacmanPos.y)*/) {
                    clearInterval(pacmanInterval);
                    clearInterval(blinkyInterval);
//                    clearInterval(inkyInterval);
                    b.innerHTML = "<h1>Game Over</h1>";
                }
                if (map[38] === true) {
                    if (pacmanPos.x - 1 >= 0 && pacmanPos.x - 1 < ROW_MAX && pacmanPos.y >= 0 && pacmanPos.y < COL_MAX && (matrix[pacmanPos.x - 1][pacmanPos.y] === 'pp' || matrix[pacmanPos.x - 1][pacmanPos.y] === 'PP' || matrix[pacmanPos.x - 1][pacmanPos.y] === 'ze'))
                        pacmanDirection = {x: -1, y: 0};
                }
                if (map[37] === true) {
                    if (pacmanPos.x >= 0 && pacmanPos.x < ROW_MAX && pacmanPos.y - 1 >= 0 && pacmanPos.y - 1 < COL_MAX && (matrix[pacmanPos.x][pacmanPos.y - 1] === 'pp' || matrix[pacmanPos.x][pacmanPos.y - 1] === 'PP' || matrix[pacmanPos.x][pacmanPos.y - 1] === 'ze'))
                        pacmanDirection = {x: 0, y: -1};
                }
                if (map[40] === true) {
                    console.log("left");
                    if (pacmanPos.x + 1 >= 0 && pacmanPos.x + 1 < ROW_MAX && pacmanPos.y >= 0 && pacmanPos.y < COL_MAX && (matrix[pacmanPos.x + 1][pacmanPos.y] === 'pp' || matrix[pacmanPos.x + 1][pacmanPos.y] === 'PP' || matrix[pacmanPos.x + 1][pacmanPos.y] === 'ze')) {
                        console.log("down");
                        pacmanDirection = {x: 1, y: 0};
                    }
                }
                if (map[39] === true) {
                    if (pacmanPos.x >= 0 && pacmanPos.x < ROW_MAX && pacmanPos.y + 1 >= 0 && pacmanPos.y + 1 < COL_MAX && (matrix[pacmanPos.x][pacmanPos.y + 1] === 'pp' || matrix[pacmanPos.x][pacmanPos.y + 1] === 'PP' || matrix[pacmanPos.x][pacmanPos.y + 1] === 'ze'))
                        pacmanDirection = {x: 0, y: 1};
                }
            }
        };
    }
    main();
</script>
</html>